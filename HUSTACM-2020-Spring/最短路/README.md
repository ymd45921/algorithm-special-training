# HUSTACM 2020 专题： 最短路

关于模板的整理以及模板算法的学习可以参见[这里>>](template/README.md)

## 做题笔记

### Luogu P4042

看起来，一个怪是用法术解还是脸解取决于法术的法力值消耗和脸解掉它以及它全部的衍生物的法力值消耗，取小的就行了——看起来像极了动态规划题。

但是因为怪死了可以招自己，样例里也安排的明明白白：存在正环则不满足动态规划所要求的后效性，所以 DP 实际上用不得；事实上看了题解才知道这实际上是一个考察了 SPFA 变形的题目。

SPFA 比 BF 优化的地方在于，它指出了**当一条边有希望更新它的一个端点的最短路值，当且仅当它的另一个端点的最短路值被更新过**。在代码实现中，这些有希望更新其他节点的值根据先来后到的顺序，被放入了一个队列中。一般来说，对于一个点，它可以有使用与它相连的边更新其他点，或者被连接的点中的一个更新的两种情况；因为更新可以**一更多**，利用第一种关系维护已经被更新的节点，难度肉眼可见的较低（前者的每次更新处理都是有效的，但后者需要扫描所有前驱才能找到有效的更新）。

那么回到这个问题上来，我们将怪和它亡语招的衍生物之间连**有向边**，一个怪被解掉的最小法力值由它的衍生物来更新；因此，这是一个**多更一**的关系，上面那种做法已经行不通了；因此，我们维护的是可能被更新的节点，每次使用它所有的前驱节点的值以及自身的加权来更新自己的值。

对应地，如果一个节点被更新了，那么需要将其后继节点再次入队：因为它们可能被刚更新的节点再次更新。

那么如何知道一个怪的法力值是否更新了呢？因为和一般的最短路不一样，本题并没有明确的起点和终点，向前向追溯也是无穷无尽的。这里可以假设我们最开始使用法术解所有的怪——这也是一个怪被解掉的上界，并假定它们都可以更新其他节点，然后运行 SPFA：正环会自行膨胀大于上界，所以不会影响答案。

从动态规划的层面上看，我们最开始从上界开始，一层一层的向内松弛，这也许也包含了动态规划的记忆性思想吧？

