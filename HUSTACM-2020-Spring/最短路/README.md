# HUSTACM 2020 专题： 最短路

关于模板的整理以及模板算法的学习可以参见[这里>>](template/README.md)

## 做题笔记

### Luogu P4042

看起来，一个怪是用法术解还是脸解取决于法术的法力值消耗和脸解掉它以及它全部的衍生物的法力值消耗，取小的就行了——看起来像极了动态规划题。

但是因为怪死了可以招自己，样例里也安排的明明白白：存在正环则不满足动态规划所要求的后效性，所以 DP 实际上用不得；事实上看了题解才知道这实际上是一个考察了 SPFA 变形的题目。

SPFA 比 BF 优化的地方在于，它指出了**当一条边有希望更新它的一个端点的最短路值，当且仅当它的另一个端点的最短路值被更新过**。在代码实现中，这些有希望更新其他节点的值根据先来后到的顺序，被放入了一个队列中。一般来说，对于一个点，它可以有使用与它相连的边更新其他点，或者被连接的点中的一个更新的两种情况；因为更新可以**一更多**，利用第一种关系维护已经被更新的节点，难度肉眼可见的较低（前者的每次更新处理都是有效的，但后者需要扫描所有前驱才能找到有效的更新）。

那么回到这个问题上来，我们将怪和它亡语招的衍生物之间连**有向边**，一个怪被解掉的最小法力值由它的衍生物来更新；因此，这是一个**多更一**的关系，上面那种做法已经行不通了；因此，我们维护的是可能被更新的节点，每次使用它所有的前驱节点的值以及自身的加权来更新自己的值。

对应地，如果一个节点被更新了，那么需要将其后继节点再次入队：因为它们可能被刚更新的节点再次更新。

那么如何知道一个怪的法力值是否更新了呢？因为和一般的最短路不一样，本题并没有明确的起点和终点，向前向追溯也是无穷无尽的。这里可以假设我们最开始使用法术解所有的怪——这也是一个怪被解掉的上界，并假定它们都可以更新其他节点，然后运行 SPFA：正环会自行膨胀大于上界，所以不会影响答案。

从动态规划的层面上看，我们最开始从上界开始，一层一层的向内松弛，这也许也包含了动态规划的记忆性思想吧？

### Luogu P3403

这是一个**同余最短路**的例题。

首先要说明的是，同余最短路和最短路之间的关系，就像差分约束最短路（构建最短路不等式）和最短路之间的关系一样，是一个利用最短路算法作为工具快速对模型求解的方法。

首先题意：

> 有 $x, y, z \in N+$，求 $\#A$ 的大小：其中 $A = \{i\  |\  ax + by + cz = i;\  a, b, c, i \in N;\  i \leq h\}$。

如果数据比较小，可以考虑 DP、exgcd 等方案；但是本题数据范围 `long long`，所以必须要使用同余最短路进行优化。

#### 同余最短路

下面是同余最短路的概念：

> 同余最短路的问题是形如“给定m个整数，求这m个整数能拼凑出多少的其他整数（这m个整数可以重复取）”，以及“给定m个整数，求这m个整数不能拼凑出的最小（最大）的整数”的问题。

如果要建成模型，就是一个带权无向图，点 u 到点 v 之间是否存在一条路径，满足路径长度为 L；数据范围可以到 `long long`。

先考虑简单的情况：假设现在只有两个数 x 和 y，那我们可以考虑先使用 x，凑出对于 mod y 来说所有可能的值的最小值；那么对于一个具体的余数，我们就可以从最小值开始累加 y，快速统计可行范围内这个“数系”中的较大值。

然后我们对上面这个简单的道理建模：

- 状态点 i：表示了 $ax\ \%\ y = i$ 的状态；对于一个数字的余数系，其他数字可以互相相加到达其他的余数比如 $j$。形式化地，有 $i + z \ mod\  y = j$。
- 最小值：从初始状态出发，可以到达某状态（余数）的经过最小的边数；也就是对应的图上的从初始状态到达对应状态的最短路。这可以使用最短路算法快速求出。
- 边：根据上面的说明，显然可以得到对于每一个余数，加上任何一个其他数字，可以到达一个新的余数；那么这两种状态之间可以连接一个这个数字大小的边。

总而言之，就是对于这种类型的问题，我们使用这样的建模方式，将最简单的道理转化为可以被最短路算法处理的模型，并使用最短路算法快速求出。

#### 这个题目的做法？

我们这样考虑：先选取 y 和 z 可以累加到达的 x 的合法剩余系，也就是考虑 by + cx mod x 可能到达的位置；这样大于 x 的位置就都可以累加得到，并且方便地统计。

然后这样建模：假设选取 z 作为余数系的模数，那么对于 [0, z - 1] 的每一个值建立一个节点，并且根据取模加法连接长度为 x 和 y 的边；因为跳楼机从一楼开始，所以初始状态为 1；从 1 出发运行最短路算法，就可以求出对于每个余数可以到达的合法最小值（如果为 `inf` 则说明不存在这样的合法值）。

然后就可以使用常数时间计算出每个余数在范围内的有效值的个数，累加即可得到答案。