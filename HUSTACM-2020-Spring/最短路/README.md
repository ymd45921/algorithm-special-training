# HUSTACM 2020 专题： 最短路

关于模板的整理以及模板算法的学习可以参见[这里>>](template/README.md)

## 知识点概述

### 基本算法

有 SPFA（B-F）、Dijkstra 和嗯搜；前两个的板子都有写好了。

SPFA 的最坏复杂度是 Bellman-Ford 的复杂度，它的优化体现在它只尝试松弛出现在队列中的边；而 Bellman-Ford 每一次操作都会松弛所有的边。

在某些情境下，可能需要求最长路：此时只需要改变最短路算法中的松弛办法即可。

### 常见应用

有些东西看起来不是最短路，但是可以通过建模为图，从而转化为可以使用最短路解决的问题：

#### 同余最短路

是一种建模方法；用来求解由给定的一组整数可以组成的数字，包括但不仅限于一个范围内可以构成的数字数量，可以构成的最小数字，不可以构成的最大数字等问题。

因为实数系可以根据对一个确定的整数的余数进行分类，记为同余系；我们可以选择这组整数中的一个作为同余系的模数。如果可以求出同余系中的每一个余数的最小值，那么其他的数字一定可以由这个数字进行累加模数得到。因此，选择一个作为模数建立同余系，从余数节点出发到达其他余数建图，使用最短路算法，就可以得到可以到达的余数的最小值（最短路长）。

#### 差分约束系统

是一组 n 元的一次不等式，形如 $x_i - x_j \leq C_k$，每一组不等关系都是限定了两个未知变量**做差**获得的。一般问题的形式是需要求出一组解，满足所给的全部约束条件。

我们可以把约束条件变形为 $x_i \leq x_j + C_k$，就可以类比三角不等式进行推广：把每一个变量看作一个节点，对于每一个约束条件（形如上述）从 $x_j$ 向 $x_i$ 连接一条长 $C_k$ 的有向边，以此建图。如果使用 SPFA，则需要建立超级源点（到每个变量连接一条长度 0 的边）；也可以不建，但是所有节点入队；如果图中没有负环，那么求出的最短路/最长路就是这个差分约束系统的一组解。

因为差分约束系统问题中负边权几乎不可避，所以 Dijkstra 几乎是不能用的。

对于某些特殊的约束条件（指非两个未知变量做差小于常量的形式），可以进行转换：

- $x_i - x_j \geq C_k$：两边同时乘以 -1，变化为 $x_j - x_i \leq -C_k$；~~也可跑最长路~~
- $x_i - x_j = C_k$：拆分为 $x_i - x_j \leq C_k$ 和 $x_i - x_j \geq C_k$ 两个等式。
- $x_i - x_j < C_k$：因为这是整数范围内的问题，所以转化为 $x_i - x_j \leq C_k - 1$ 即可。

差分约束系统有很多解系，在一个确定的解系中，可以根据确定一个变量的值（偏移量）来获得一个确定的可行解；而涉及到差分约束系统的解系，则有了最大解和最小解的概念；

关于差分约束系统的最大解和最小解的概述：

- 这里的最大解是针对形如 $x_i - x_j \leq C_k$ 的差分约束系统而言的，最小解是针对 $x_i - x_j \geq C_k$ 而言。
- 最大解指在某个变量确定的情况下，其他的变量都能取到能取的最大值；最小解则 $\textrm{Vice Versa}$。
- 形如 $x_i - x_j \leq C_k$ 的差分约束系统使用最短路算法求解最大值，另一种相应的使用最长路算法求解

如果问题需要求取最小值，那么应该将约束条件对应的转化为后一种差分约束系统，求解**最长路**；否则，转化为前一种，求解**最短路**。以通常的差分约束系统进行解释：对于约束图上的任意路径 $p(S, x_{1…n}, T)$，那么该路径上的边为代表的约束条件是 $x_i - x_{i - 1} \leq w_{x_{i - 1} \to x_i}$；对路径上所有的 $n$ 条路径和增加的超级源点的边，可得 $X_T - X_S \leq dis_p$，其中 $X_S$ 可以是指定的初始偏移（比如 0），$dis_p$ 是任意路径长度；记从该路径起点到终点的最短路是 $P_{S \to T}$，则有 $X_T \leq X_S + dis_P \leq X_S + dis_p$，显然当 $X_T = X_S + dis_P$ 时，$X_T$ 取得了最大值；对于另一种差分约束系统也是如此。

#### 最短路径树

基础是单源最短路；以一个节点为根，树上所有节点到根的路径都是原图中的最短路。实际求解时只需要在使用单源最短路算法的时候增加一个前驱数组，用来记录更新的源，就可以依靠这个信息建立最短路径树。

## 做题笔记

### Luogu P4042

看起来，一个怪是用法术解还是脸解取决于法术的法力值消耗和脸解掉它以及它全部的衍生物的法力值消耗，取小的就行了——看起来像极了动态规划题。

但是因为怪死了可以招自己，样例里也安排的明明白白：存在正环则不满足动态规划所要求的后效性，所以 DP 实际上用不得；事实上看了题解才知道这实际上是一个考察了 SPFA 变形的题目。

SPFA 比 BF 优化的地方在于，它指出了**当一条边有希望更新它的一个端点的最短路值，当且仅当它的另一个端点的最短路值被更新过**。在代码实现中，这些有希望更新其他节点的值根据先来后到的顺序，被放入了一个队列中。一般来说，对于一个点，它可以有使用与它相连的边更新其他点，或者被连接的点中的一个更新的两种情况；因为更新可以**一更多**，利用第一种关系维护已经被更新的节点，难度肉眼可见的较低（前者的每次更新处理都是有效的，但后者需要扫描所有前驱才能找到有效的更新）。

那么回到这个问题上来，我们将怪和它亡语招的衍生物之间连**有向边**，一个怪被解掉的最小法力值由它的衍生物来更新；因此，这是一个**多更一**的关系，上面那种做法已经行不通了；因此，我们维护的是可能被更新的节点，每次使用它所有的前驱节点的值以及自身的加权来更新自己的值。

对应地，如果一个节点被更新了，那么需要将其后继节点再次入队：因为它们可能被刚更新的节点再次更新。

那么如何知道一个怪的法力值是否更新了呢？因为和一般的最短路不一样，本题并没有明确的起点和终点，向前向追溯也是无穷无尽的。这里可以假设我们最开始使用法术解所有的怪——这也是一个怪被解掉的上界，并假定它们都可以更新其他节点，然后运行 SPFA：正环会自行膨胀大于上界，所以不会影响答案。

从动态规划的层面上看，我们最开始从上界开始，一层一层的向内松弛，这也许也包含了动态规划的记忆性思想吧？

#### 拓扑排序做法

设杀死怪物 i 所需要消耗的法力值是 $F$；那么有 $F_i = min(K_i, S_i + \sum_{j\in R_i}F_j)$，该式的第二项是一个拓扑排序的转移式；但是题中的图存在环，又因为 $F_i \leq K_i$，故可以在环上 $K_i$ 最小的地方贪心断开，使得原图成为 DAG，然后按照拓扑排序的方式进行转移。时间复杂度是 $O(n\ log\ n + \sum R)$。

**2021-1-20 UPD**: 有群友说这个题 SPFA 的复杂度有点假，并提供了类 Dijkstra 的做法[链接](建议参考：![img](file:///C:\Users\shiroha\AppData\Roaming\Tencent\TIM\Temp\%W@GJ$ACOF(TYDYECOKVDYB.png)https://www.cnblogs.com/asuldb/p/11291426.html)。

**2021-1-23 UPD**：何佬提供了一种类似拓扑排序的做法，并提供了 [AC 代码](https://loj.ac/s/1044151)。

### Luogu P3403

这是一个**同余最短路**的例题。

首先要说明的是，同余最短路和最短路之间的关系，就像差分约束最短路（构建最短路不等式）和最短路之间的关系一样，是一个利用最短路算法作为工具快速对模型求解的方法。

首先题意：

> 有 $x, y, z \in N+$，求 $\#A$ 的大小：其中 $A = \{i\  |\  ax + by + cz = i;\  a, b, c, i \in N;\  i \leq h\}$。

如果数据比较小，可以考虑 DP、exgcd 等方案；但是本题数据范围 `long long`，所以必须要使用同余最短路进行优化。

#### 同余最短路

下面是同余最短路的概念：

> 同余最短路的问题是形如“给定m个整数，求这m个整数能拼凑出多少的其他整数（这m个整数可以重复取）”，以及“给定m个整数，求这m个整数不能拼凑出的最小（最大）的整数”的问题。

如果要建成模型，就是一个带权无向图，点 u 到点 v 之间是否存在一条路径，满足路径长度为 L；数据范围可以到 `long long`。

先考虑简单的情况：假设现在只有两个数 x 和 y，那我们可以考虑先使用 x，凑出对于 mod y 来说所有可能的值的最小值；那么对于一个具体的余数，我们就可以从最小值开始累加 y，快速统计可行范围内这个“数系”中的较大值。

然后我们对上面这个简单的道理建模：

- 状态点 i：表示了 $ax\ \%\ y = i$ 的状态；对于一个数字的余数系，其他数字可以互相相加到达其他的余数比如 $j$。形式化地，有 $i + z \ mod\  y = j$。
- 最小值：从初始状态出发，可以到达某状态（余数）的经过最小的边数；也就是对应的图上的从初始状态到达对应状态的最短路。这可以使用最短路算法快速求出。
- 边：根据上面的说明，显然可以得到对于每一个余数，加上任何一个其他数字，可以到达一个新的余数；那么这两种状态之间可以连接一个这个数字大小的边。

总而言之，就是对于这种类型的问题，我们使用这样的建模方式，将最简单的道理转化为可以被最短路算法处理的模型，并使用最短路算法快速求出。

#### 这个题目的做法？

我们这样考虑：先选取 y 和 z 可以累加到达的 x 的合法剩余系，也就是考虑 by + cx mod x 可能到达的位置；这样大于 x 的位置就都可以累加得到，并且方便地统计。

然后这样建模：假设选取 z 作为余数系的模数，那么对于 [0, z - 1] 的每一个值建立一个节点，并且根据取模加法连接长度为 x 和 y 的边；因为跳楼机从一楼开始，所以初始状态为 1；从 1 出发运行最短路算法，就可以求出对于每个余数可以到达的合法最小值（如果为 `inf` 则说明不存在这样的合法值）。

然后就可以使用常数时间计算出每个余数在范围内的有效值的个数，累加即可得到答案。

### Luogu P3953

题目要求统计的是给定两点之间距离小于最短路 + K 的路径总数；我们分成三步：

##### 不考虑 K，只统计最短路

已经做了 P1144 最短路计数；只不过因为边长不是 1，所以需要使用最短路算法而不是 BFS。

##### 不考虑零边

K 很小，考虑到计数问题都可以使用动态规划来解，所以考虑动态规划：首先从起点跑一边单源最短路，维护动态规划的数组 $dp[u][k]$，其含义是从起点到 u，距离小于到 u 的最短路 + k 的路径数量；然后使用边的信息更新这个数组。需要注意的是，我们要先更新最短路较短的点，而不能按照下标的顺序更新；这可以通过对单源最短路排序来实现。

但是这样依然不能过这个题，以为完全没有判断无穷的情况。

##### 考虑全部的情况

上述情况中还缺失了对于零边的考虑：由零边构成的零环可以使得情况数量变为无穷大。

此外，零边的两端的端点的最短路长度是一样的，但是显然它们的更新顺序不能一致；因此在上述对最短路排序的基础上，还需要加上拓扑排序：先更新最短路焦段，拓扑序靠前的节点。

使用拓扑排序也可以判断零环：当拓扑排序完成后，若某点仍然存在入度，说明这个点在一个零环上；只要这个零环存在于一条从起点到终点的合法路径上，那么答案就是无穷大；为了判明这一点，我们可以先建反图，从终点跑一次单源最短路：如果（起点 - 该点）+（该点 - 终点）的和在允许的范围内，则说明答案无穷大。

#### 一个其他的做法



### Luogu P3645

看起来挺简单的，但是写代码的时候如果不理清楚还是挺容易写错的；

首先这个题目就像看到的那样是一个无权无向图上的 BFS，但是还需要注意到这些事：

- 一条狗的活动空间是限定的；尽管消息在其间传递，但是对应的狗的活动空间不会变化
- 将一个状态记为 (i, j)：指运送消息的狗在点 i，跳跃力为 j；根据跳跃距离进行分类讨论：
  - $j \leq \sqrt{n}$：这样最多只有 $n\sqrt{n}$ 种状态（n 个位置，√n 个距离）
  - $j \gt \sqrt{n}$：这样最多有 $m\sqrt{n}$ 种状态（m 条狗的余数系，每条狗 $\lfloor\frac{n}{j}\rfloor < \sqrt{n}$ 个可行位置
- 综上所述，状态数是 $(n + m)\sqrt{n}$ 的；在其上进行 BFS 的复杂度也是 $O((n + m)\sqrt{n})$ 的。

可以建图，也可以不建图，直接转移。

### Luogu P2993

这个题有两个部分组成：首先由给定图求出指定源点的最短路径树，然后再在这棵树上进行点分治。

#### 最短路径树（SPT）

和最小生成树（MST）不同；MST 没有根节点的说法，只要这棵树联通了所有的节点，并且所有的边的权值和最小，就是一颗 MST；但是 SPT 是相对于一个根节点而言的，要求所有其他节点到这个点的路径都是原图中的最短路径。<font color="red">某节点的最短路径树未必是原图的最小生成树。</font>

求解 MST 的算法有类似 DFS 的 Prim 算法，以及只需要简单的并查集和排序的 Kruskal 算法；而求解 SPT 问题的方法和单源最短路相似，但是在其基础上还要记录路径，有 Dijkstra 算法。

#### 点分治

