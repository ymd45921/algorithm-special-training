# 最短路模板

以下的更新已经同步的更新到[我的模板](https://github.com/ymd45921/XCPC_pattern/blob/main/Graph%20Theory/Shortest%20Path/stanard.cpp)中。

## Dijkstra + 优先队列优化

太经典了，就是不能处理负边权图：不管你使用什么方法

给所有的边权加上固定值变成正数？这是**错误**的：

- 这样不仅边权会对最短路产生影响，路径包含的边数也会
- 相当于每多包含一条边，就要额外产生固定值的路长，这显然不合理

所以需要其他的办法来处理负边权。

## Johnson 全源最短路

因为 n 次 Dijkstra 在稀疏图里的表现还是比 Floyd 好，所以得想个办法用它：

但是我们需要新的处理负边权的方法：

- 我们新建一个虚拟节点（设它的编号为 0）。从这个点向其他所有点连一条边权为 0 的边。
- 接下来用 Bellman-Ford 算法求出从 0 号点到其他所有点的最短路，记为 $h_i$
- 假如存在一条从 u 点到 v 点，边权为 w 的边，则我们将该边的边权重新设置为 $w + h_u - h_v$

接下来以每个点为起点，跑 n 轮 Dijkstra 算法即可求出任意两点间的最短路了。

为什么正确？

- 证明正确性：预处理跑出来的 h 就相当于是**势能**。可以随便假设一条路径，然后加上这个附加项，就会发现它没有影响到路径的长短，最短路算法可以跑出正确结果

- 证明边权非负：使用三角形不等式，一定满足 $h_v \leq h_u + w_{u, v}$，移项就可以整理得到我们标记的新的边权，显然是非负的

所以，这么做就可以跑出正确的最短路；当然要先减掉我们标记的势能附加项。

## SPFA 判负环

有两种做法；基于这两种做法也可以写成 BFS/DFS 形式：

- 方法一：统计路径上的点数
  - 创建空数组用来统计统计路径上的点数，假设数组的名字是 `cnt`
  - 初始化 `cnt[i] = 1`，更新最短路的时候同步更新 `cnt[v] = cnt[u] + 1`
  - 如果存在某个点 `i`，使得 `cnt[i] > n`，则说明存在负环

- 方法二：统计节点的入队次数
  - 若某节点入队次数大于 n，则说明存在负环

一般来说，方法一比方法二更快，所以模板代码使用的是方法一；方法二写起来也不难就是了

当图中存在负环的时候，DFS 判负环比 BFS 快；但是在其他情况下，DFS 远慢于 BFS 实现，所以模板使用了 BFS。

## 求最短路径树

一般来说求最短路径树和求最短路径没太大区别，所以单源最短路的算法也可以使用，只是在这基础之上还要进一步处理就是了。

### 使用 Dijkstra 直接求出

和 Dijkstra 单源最短路径算法并没有什么本质区别，只要在求最短路的时候顺便记录一下前驱就可以了。

当然，也可以根据题目的要求进行适当的修改；比如仍然以最短路径作为主要标准，但引入了其他的次要标准的场合下：一般可以在当前路径长度等于最短路径长度的情况下，进行特判次要标准。

### Dijkstra + DFS

这应该不算是一种做法。就是单纯的先跑一遍单源最短路，得到 `dis` 数组；然后在进行 DFS 重新建树：如果一条边 (u, v, w) 在要求的 SPT 上，且**它的一个端点 `u` 已经被访问**，那么它一定满足 `dis[v] == w + dis[u]`；次要条件可以在进行 DFS 之前先对边进行某种排序，就可以保证。

但是这种做法仍然有存在的必要：因为某些次要条件可能需要先对边进行处理才能够得到强力保障，或者是单纯的更好写。

## O(na) 的同余最短路

首先需要说明：路径长度不超过 x 的单源最短路是可以做到线性时间 O(x) 的，而不是像单源最短路算法那样还需要带一个 log；两者孰优孰劣需要取决于实际情况，虽然我不知道这种方法的具体操作就是了。

同余最短路是一种建模方法，一般的建模并使用 Dijkstra 求解的时间复杂度是 $O(na_{min}·log \ a_{min})$ 的；而现在要说明的做法的时间复杂度是 $O(n·a_{max})$。

一般的建模求出了以选定的 a 的剩余系中，每一个余数可以达到的最小值 $dis[x]$；但是可以注意到，$dis[x]$ 总是可以表示为 $x + a * k[x]$ 的形式。

为了方便更新，我们选择的 $a$ 总是 $a_{max}$；这样，当有 $x + a' \geq a$ 的时候，因为 a 是最大的，所以 $x + a' - a \lt a$ 一定成立；就有 $k[x]a + x + a' = (k[x] + 1)a + (x + a' - a)$。因此，可以使用 $k[x] + 1$ 来更新 $k[x + a' - a]$；这就是一个 **01 最短路**，使用 BFS 解决即可，时间复杂度 $O(na)$。

## SPFA 的 SLF+LLL 优化策略

一些优化方法，可以让 SPFA 跑单源最短路的时候稍微快一点，但是本质上并没有什么变化：

### SLF (Small Label First)

具体的说就是使用双端队列：当有节点要**加入**队列的时候，判断它的距离是否小于当前队首的距离，如果是，则将它加入队首，否则加入队尾。

### LLL (Large Label Last)

当要从队列中**取出**元素时，比较这个节点的距离和进队的所有节点的平均值；如果它的距离更大，就取出放到队尾，直到可以取出一个距离小于平均距离的节点。

上面两种优化的说法并不矛盾，可以同时附加到朴素 SPFA 算法中；还有一种优化的思想是 DFS，因为可以连续的松弛节点，但是也只有在判断负环的时候有较大的优势，所以这里就不写了。