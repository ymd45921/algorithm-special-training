# 最短路模板

以下的更新已经同步的更新到[我的模板](https://github.com/ymd45921/XCPC_pattern/blob/main/Graph%20Theory/Shortest%20Path/stanard.cpp)中。

## Dijkstra + 优先队列优化

太经典了，就是不能处理负边权图：不管你使用什么方法

给所有的边权加上固定值变成正数？这是**错误**的：

- 这样不仅边权会对最短路产生影响，路径包含的边数也会
- 相当于每多包含一条边，就要额外产生固定值的路长，这显然不合理

所以需要其他的办法来处理负边权。

## Johnson 全源最短路

因为 n 次 Dijkstra 在稀疏图里的表现还是比 Floyd 好，所以得想个办法用它：

但是我们需要新的处理负边权的方法：

- 我们新建一个虚拟节点（设它的编号为 0）。从这个点向其他所有点连一条边权为 0 的边。
- 接下来用 Bellman-Ford 算法求出从 0 号点到其他所有点的最短路，记为 $h_i$
- 假如存在一条从 u 点到 v 点，边权为 w 的边，则我们将该边的边权重新设置为 $w + h_u - h_v$

接下来以每个点为起点，跑 n 轮 Dijkstra 算法即可求出任意两点间的最短路了。

为什么正确？

- 证明正确性：预处理跑出来的 h 就相当于是**势能**。可以随便假设一条路径，然后加上这个附加项，就会发现它没有影响到路径的长短，最短路算法可以跑出正确结果

- 证明边权非负：使用三角形不等式，一定满足 $h_v \leq h_u + w_{u, v}$，移项就可以整理得到我们标记的新的边权，显然是非负的

所以，这么做就可以跑出正确的最短路；当然要先减掉我们标记的势能附加项。

## SPFA 判负环

有两种做法；基于这两种做法也可以写成 BFS/DFS 形式：

- 方法一：统计路径上的点数
  - 创建空数组用来统计统计路径上的点数，假设数组的名字是 `cnt`
  - 初始化 `cnt[i] = 1`，更新最短路的时候同步更新 `cnt[v] = cnt[u] + 1`
  - 如果存在某个点 `i`，使得 `cnt[i] > n`，则说明存在负环

- 方法二：统计节点的入队次数
  - 若某节点入队次数大于 n，则说明存在负环

一般来说，方法一比方法二更快，所以模板代码使用的是方法一；方法二写起来也不难就是了

当图中存在负环的时候，DFS 判负环比 BFS 快；但是在其他情况下，DFS 远慢于 BFS 实现，所以模板使用了 BFS。




